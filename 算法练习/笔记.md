# 滑动窗口
## 滑动窗口使用的标志
> 1、计算数组中的某一部分数据的长度！（最短的、最长的、次长次短也能算，或者是固定长度的数据中要做什么事）
  2、这些长度还都是挨着的



# 双指针
## 双指针使用的标志
> 1、计算数组中两个元素的和。
  2、数组中的元素告诉你是有序的，不是有序的要排列成有序的才能用。
  3、在链表中也有比较好的用法，比如计算链表是否有环
## 双指针在链表中的使用
> 1、删除倒数第几个元素的时候，当然这种在数组中也能用。

# 哈希表
> 哈希表方法，我用下来用两种实现形式，一种是借助map，为了提高性能接触unordered_map；
 另一种就是数组的形式。
 那种什么时候，选择什么样的哈希表呢？
 一般来说：
## 选择数组形式哈希表
> 做key值的元素数量是确定的，多少无所谓，一定要确定；
  因为要是不确定的话，前期定义数组的时候，你怎么定义。
  一般而言，我目前碰到的就是各个英文字母出现的数量。

## map形式哈希表
> 基本上就是数组形式的用不了的才用，而且基本上都是unordered_map或者是unordered_set
  0、题目中的条件中出现类似“某个元素再次出现会怎么样”，这个时候就用，根据要不要value选择set或者是map
  1、要做hash的数据的长度不确定的时候，
  什么时候不确定呢，比如key要从任意的数字中取值，如果用用数字做数组做下标，这个时候，数组没有办法定义。
  2、单独开个遍历，要从hash数据中找到一个数组，如果这个数据能在hash赋值的时候顺便把对hash的值的读取也错了，数组可以的。
  如果不是，还用数组的话，只能for遍历，时间复杂的是n，如果用unordered_map时间复杂度就是1.map的复杂的是logn

# 区间
> 区间不是像“双指针、哈希表”这种意思代表算法的方式。
  而是很直白的，是指数据结构中有“一部区间”的数据是满足要求的。

# 贪心
> 思想很简单，就是先算局部最优解，然年再计算全局最优解。
  这样的话就会就把复杂的问题分开。
  说起来很简单，还是需要一一解答。

# 栈
> 说说栈把，这个思路比较简单。
  那么什么时候用它呢？
  他的特点就是很方便去拿、删除头元素。以及先入后出的结构。
  但是在我实际的使用的时候：
  如果你发现一个题目，如果是对新来的数据先做处理，新的处理完了，然后才是处理旧的数据，
  核心“就是从后往前倒腾数据”。这种处理数据的方式就适合；
  或者是数据表达的计算，其实说白的还是这种思路，
  先把旧的数字存进去，然后等到新的数据符合条件了，开始从后往前倒腾数据，
  可以考虑用这个数据结构。

# 链表
> 链表中通过循环结构，往后面插入数据
```C++ []
  ListNode * note = new ListNode(0);
  ListNode *pre = note;
  //最后返回
  return note->next;
 ```
>链表插入数据，两种方法：
 1、end->next=head； 接原来的节点。
 缺点：
	但是要注意的是，这样会把原先整个的链表都接上。
	在有些题目中，需要end->next =nullptr。从而保证逻辑上end后面都是nullptr。
 优点：
	好处是生空间复杂度
 2、end->next = new ListNode(head->val); 接新的节点，数据和head的数据一样，
 优点：
	不用在需要end->next =nullptr。每次插入新的end->next就是nullptr，否则看你的构造函数写的对不对。
缺点：
	空间复杂度稍微差点。
 3、这部分的思想，参考82. 删除排序链表中的重复元素 II，是很好的例子

> 链表删除元素，有两种方法：
 1、删除头部head
	head=head->next;		
 2、删除p后面的一个点：
	p->next = p->next->next;
 3、删除slow后面的所有的点
	auto slow = head;
	auto nHead = slow->next;//slow后面的所有的点
	slow->next = nullptr;// slow以及slow前面的所有的点

> 链表的浅拷贝的思考
	这个问题，对我而言是指针的浅拷贝，这样的话所有的指针都可以管理同一个指针。
	贴一些关键的代码：
	auto slow = head;
	//以下代码都会对head链表更改！但是具体的代码不太一样。
	slow = slow->next;//这个也对更改了，特殊的是head每次被赋值的都是原来的值
	slow->next =nullptr; // 这个会造成head后面的链表断开


# 树
## 遍历
> 深度优先遍历
	前序遍历（递归法，迭代法）
	中序遍历（递归法，迭代法）
	后序遍历（递归法，迭代法）
	对这三种遍历方式的总结就是：
	左中右是怎么排列的：
	1、什么序，中就在哪
	2、左右排序固定
 广度优先遍历
	层次遍历（迭代法）

## 关于树的一些总结
> 1、做了一些题目。尤其是对于递归而言，每一次递归的开始，都把他理解为一个小子树的处理，会更好。
  2、像这种返回bool的递归，一定要确定什么时候返回true，什么时候返回false。
	 然后在return的地方调用递归。
	参考101. 对称二叉树、112. 路径总和
	基本上都是这种做法
  3、分析的代码的时候，方便理解或者是写，就从叶子结点往上走，好理解
	TreeNode* left = lowestCommonAncestor(root->left, p, q);
	TreeNode* right = lowestCommonAncestor(root->right, p, q);
	这两行代码，如果要一层一层递归进去，理解很不好理解。
	可以简化理解，这个思路在任何递归的时候，都比较好用。
	lowestCommonAncestor(root->left, p, q);  就是当前root的左子树的结果
	lowestCommonAncestor(root->right, p, q); 就是当前root的右子树的结果
	不管它内部是怎么递归的，就知道这个结果就行。
	参考：236. 二叉树的最近公共祖先

## 树的高度和深度 
>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。
 
 根据以下两点，做题的时候，选择不同的思路
 深度可以从上到下去查 所以需要前序遍历（中左右），
 高度只能从下到上去查，所以只能后序遍历（左右中）

 比如验证平衡二叉树
 是不是二叉树要看它的左右孩子的高度是不是差1，那么就选择后序遍历

## 关于树中回溯的总结
 > 回溯基于的数据结构最好是vec或者是arry这种，加的时候也是一次，删除的也是一次。不会受到数据自身长度的影响。
   比如：
   257. 二叉树的所有路径
	   vector<int> path;//path一定要vec，如果要用string的话，如果添加了一个3位数字，在回溯的时候，要回溯3次，关键你还得记录他的位数。用vec的话，pop一次就行了

## 在树中递归结束条件的写法
 > 1、如果他的任意一个子树为空，就不满足要求，就退出。
	比如验证是否为平衡二叉树的时候，
	“一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 ”
	其中任意一个孩子为空的话，就会构成他的其中一个子树的高度确定了，这个时候就要返回，算另一个子树
	110. 平衡二叉树
	```C++ []
			if (node == NULL) return 0;
	 ```
  2、如果它的左右子树都为空的时候，就退出。
  一般而言，就是用来啊、判断是否遍历到了子节点。
  257. 二叉树的所有路径
  	```C++ []
	if (cur->left == NULL && cur->right == NULL) return 0;

  3、结束条件的判断的写法，要和你递归函数的入参要对应。要不然出现空指针访问的问题。
	  3.1、入参是子节点指针，结束条件的判断，一定要是对root的判断。 searchBST(root->left, val); 《-----》  if (root == NULL || root->val == val) return root; 
		如果对root->left，就会出现nullptr->left，自然就会报错。
	  3.2、入参是root节点非子节点，结束条件的判断，才可以是对root->left等判断。
	  3.3、具体什么时候采取什么样的判断，要根据入参来。而什么样的入参，要根据题目的思路来。多体会吧。
	  3.4、  700. 二叉搜索树中的搜索 可以参考这个题目


## 在树中返回值的选择
> 1、当你发现返回值不是很好写的时候，考虑一下不要返回值，数据的修改放到参数加引用的时候。这句话很白话，但有时候确实是这样。——257. 二叉树的所有路径
  2、一般情况下：如果需要搜索整棵二叉树，那么递归函数就不要返回值。如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。——具体看112，113这两个题目

## 树的题目中有些是判断，最后返回一个bool量
> 这种题目有个固定的写法，
  在递归函数中，先判断各种true、false的情况，然后都返回。
  然后再开始递归。
  参考：101. 对称二叉树 100. 相同的树

## 突然有个想法，树的题目基本上都是递归。
> 既然都是递归，我发现很多题目树的构造，都是到了叶子节点后，然后返回上去，让root-》left 和root-》right去接，
  既然是这样，在做题目的时候，思考的思路从底部往上走，可能更简单一些

## 二叉搜索树
> 1、中序遍历正确的搜索树，它的顺序是从小到大的。

# 回溯
## 总结一些
> 结果集合中有重复元素的话，基本上都要是对源数组要排序。排序的最后带来的效果各不相同。
  参考题目：39.组合数组 40.组合总和2

## 什么时候用回溯
> 多层for循环中，这个for的个数不能定下来，而是得变化，这个时候，就用回溯。
	因为它可以模拟for的遍历，弥补了for这个函数多层变化的情况。


## 确定返回值和参数——这其中一些想法

## 确定回溯函数结束条件——这其中一些想法
>子集问题和组合问题、分割问题的的区别，
子集是收集树形结构中树的所有节点的结果。
先ret.push_back() 再判断条件是否递归
参考：78. 子集
而组合问题、分割问题是收集树形结构中叶子节点的结果。
先判断条件是否递归 再ret.push_back() 
参考：39. 组合总和 131.分割回文串


## 确定单层搜索的过程——这其中一些想法
### 递归下次开始的位置
> 总之就是这次结束的位置+1 具体多种多样，不是简单的startIndex + 1 
  有可能也是+2 但总之都是结束的位置+1

### 有些时候，递归之前会进行判断。
> 重要的是else的情况，有的是continue，有的是break。选的依据是：
如果是不满足条件就不能纵向遍历了，就continue
如果是不满足条件就不能横向遍历了，就braak

### 去重要不要回溯？
>	如果要保证树层是不重复的，树枝是可以重复的。就要在for中去定义变量，并且不回溯。
	否则就得回溯。
	参考：491.递增子序列
	要注意的是：在40.组合总和II、90.子集II (opens new window)和47.全排列 II 也是保证树层不重复，树枝可重复
	但是有区别的是，491.递增子序列是不在乎相同的两个元素的位置，而其他的则是都依赖于两个相同的元素是挨边的，所以这些题目中都有排序。
	之所以是必须挨边的是因为nums[i-1]正好就能代表上个元素。nums[i-1]==nums[i]代表了有相同的元素，要是不排序，要知道两个元素是相等的就麻烦了。得是for遍历把
	去重问题，可以根据是否能让排序，来区分使用什么方法。

### 去重
> 90. 子集 II题目和40题组合问题II 是非常相似的。是40题和78题的组合
！这个问题和40题组合问题II的关键都是去重，这种问题的去重分为
树枝去重，树层去重。树枝不用去重，树层才需要去重。
nums[i-1] == nums[i] 这个时候树枝去重，树层去重都会生效，很明显不符合要求。
加上 used[i-1]==false;才能完成树枝不用去重，树层才需要去重。
(拓展，！加上 used[i-1]==true;才能完成树层不用去重，树枝才需要去重。比如90. 子集 II题目， used[i-1]==true;也行，就是比false性能差点)
树枝：used[i-1]=true，used[i]=true;
树层：used[i-1]=false，used[i]=true;