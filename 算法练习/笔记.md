# 滑动窗口
## 滑动窗口使用的标志
> 1、计算数组中的某一部分数据的长度！（最短的、最长的、次长次短也能算，或者是固定长度的数据中要做什么事）
  2、这些长度还都是挨着的



# 双指针
## 双指针使用的标志
> 1、计算数组中两个元素的和。
  2、数组中的元素告诉你是有序的，不是有序的要排列成有序的才能用。
  3、在链表中也有比较好的用法，比如计算链表是否有环

# 哈希表
> 哈希表方法，我用下来用两种实现形式，一种是借助map，为了提高性能接触unordered_map；
 另一种就是数组的形式。
 那种什么时候，选择什么样的哈希表呢？
 一般来说：
## 选择数组形式哈希表
> 做key值的元素数量是确定的，多少无所谓，一定要确定；
  因为要是不确定的话，前期定义数组的时候，你怎么定义。
  一般而言，我目前碰到的就是各个英文字母出现的数量。

## map形式哈希表
> 基本上就是数组形式的用不了的才用，而且基本上都是unordered_map或者是unordered_set
  0、题目中的条件中出现类似“某个元素再次出现会怎么样”，这个时候就用，根据要不要value选择set或者是map
  1、要做hash的数据的长度不确定的时候，
  什么时候不确定呢，比如key要从任意的数字中取值，如果用用数字做数组做下标，这个时候，数组没有办法定义。
  2、单独开个遍历，要从hash数据中找到一个数组，如果这个数据能在hash赋值的时候顺便把对hash的值的读取也错了，数组可以的。
  如果不是，还用数组的话，只能for遍历，时间复杂的是n，如果用unordered_map时间复杂度就是1.map的复杂的是logn

# 区间
> 区间不是像“双指针、哈希表”这种意思代表算法的方式。
  而是很直白的，是指数据结构中有“一部区间”的数据是满足要求的。

# 贪心
> 思想很简单，就是先算局部最优解，然年再计算全局最优解。
  这样的话就会就把复杂的问题分开。
  说起来很简单，还是需要一一解答。

# 栈
> 说说栈把，这个思路比较简单。
  那么什么时候用它呢？
  他的特点就是很方便去拿、删除头元素。以及先入后出的结构。
  但是在我实际的使用的时候：
  如果你发现一个题目，如果是对新来的数据先做处理，新的处理完了，然后才是处理旧的数据，
  核心“就是从后往前倒腾数据”。这种处理数据的方式就适合；
  或者是数据表达的计算，其实说白的还是这种思路，
  先把旧的数字存进去，然后等到新的数据符合条件了，开始从后往前倒腾数据，
  可以考虑用这个数据结构。

# 链表
> 链表中通过循环结构，往后面插入数据
```C++ []
  pre->next = new ListNode(sum % 10);
  pre = pre->next;
  ListNode * note = new ListNode(0);
  ListNode *pre = note;
  //最后返回
  return note->next;
 ```
