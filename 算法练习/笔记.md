# 二分查找
分为两种。只有这两种区别
1、左闭右闭
	while(left<=right)
	if(nums(mid) > target) right=mid-1
2、左闭右开
	while(left<right)
	if(nums(mid) > target) right=mid



# 滑动窗口
## 滑动窗口使用的标志
> 1、计算数组中的某一部分数据的长度！（最短的、最长的、次长次短也能算，或者是固定长度的数据中要做什么事）
  2、这些长度还都是挨着的



# 双指针
## 双指针使用的标志
> 1、计算数组中两个或多个元素的和。
	1.1、其实多个思路都可以用这个一个思路来解决。具体看第18题. 四数之和中的链接
  2、数组中的元素告诉你是有序的，不是有序的要排列成有序的才能用。
  3、在链表中也有比较好的用法，比如计算链表是否有环
## 双指针在链表中的使用
> 1、删除倒数第几个元素的时候，当然这种在数组中也能用。

# 哈希表
> 哈希表方法，我用下来用两种实现形式，一种是借助map，为了提高性能接触unordered_map；
 另一种就是数组的形式。
 那种什么时候，选择什么样的哈希表呢？
 一般来说：
## 选择数组形式哈希表
> 做key值的元素数量是确定的，多少无所谓，一定要确定；
  因为要是不确定的话，前期定义数组的时候，你怎么定义。
  一般而言，我目前碰到的就是各个英文字母出现的数量。

## map形式哈希表
> 基本上就是数组形式的用不了的才用，而且基本上都是unordered_map或者是unordered_set
  0、题目中的条件中出现类似“某个元素再次出现会怎么样”，这个时候就用，根据要不要value选择set或者是map
  1、要做hash的数据的长度不确定的时候，
  什么时候不确定呢，比如key要从任意的数字中取值，如果用用数字做数组做下标，这个时候，数组没有办法定义。
  2、单独开个遍历，要从hash数据中找到一个数组，如果这个数据能在hash赋值的时候顺便把对hash的值的读取也错了，数组可以的。
  如果不是，还用数组的话，只能for遍历，时间复杂的是n，如果用unordered_map时间复杂度就是1.map的复杂的是logn

# 区间
> 区间不是像“双指针、哈希表”这种意思代表算法的方式。
  而是很直白的，是指数据结构中有“一部区间”的数据是满足要求的。

# 贪心
> 思想很简单，就是先算局部最优解，然年再计算全局最优解。
  这样的话就会就把复杂的问题分开。
  说起来很简单，还是需要一一解答。

# 栈
> 说说栈把，这个思路比较简单。
  那么什么时候用它呢？
  他的特点就是很方便去拿、删除头元素。以及先入后出的结构。
  但是在我实际的使用的时候：
  如果你发现一个题目，如果是对新来的数据先做处理，新的处理完了，然后才是处理旧的数据，
  核心“就是从后往前倒腾数据”。这种处理数据的方式就适合；
  或者是数据表达的计算，其实说白的还是这种思路，
  先把旧的数字存进去，然后等到新的数据符合条件了，开始从后往前倒腾数据，
  可以考虑用这个数据结构。

# 链表
> 链表中通过循环结构，往后面插入数据
```C++ []
  ListNode * note = new ListNode(0);
  ListNode *pre = note;
  //最后返回
  return note->next;
 ```
>链表插入数据，两种方法：
 1、end->next=head； 接原来的节点。
 缺点：
	但是要注意的是，这样会把原先整个的链表都接上。
	在有些题目中，需要end->next =nullptr。从而保证逻辑上end后面都是nullptr。
 优点：
	好处是生空间复杂度
 2、end->next = new ListNode(head->val); 接新的节点，数据和head的数据一样，
 优点：
	不用在需要end->next =nullptr。每次插入新的end->next就是nullptr，否则看你的构造函数写的对不对。
缺点：
	空间复杂度稍微差点。
 3、这部分的思想，参考82. 删除排序链表中的重复元素 II，是很好的例子

> 链表删除元素，有两种方法：
 1、删除头部head
	head=head->next;		
 2、删除p后面的一个点：
	p->next = p->next->next;
 3、删除slow后面的所有的点
	auto slow = head;
	auto nHead = slow->next;//slow后面的所有的点
	slow->next = nullptr;// slow以及slow前面的所有的点
> 链表删除元素，统一方法
设置一个虚拟头结点在进行删除操作。
  参考：
  https://www.programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF
  ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
  dummyHead->next = head; // 将虚拟头结点指向head，这样方便后面做删除操作

> 链表的浅拷贝的思考
	这个问题，对我而言是指针的浅拷贝，这样的话所有的指针都可以管理同一个指针。
	贴一些关键的代码：
	auto slow = head;
	//以下代码都会对head链表更改！但是具体的代码不太一样。
	slow = slow->next;//这个也对更改了，特殊的是head每次被赋值的都是原来的值
	slow->next =nullptr; // 这个会造成head后面的链表断开


# 树
## 遍历
> 深度优先遍历
	前序遍历（递归法，迭代法）
	中序遍历（递归法，迭代法）
	后序遍历（递归法，迭代法）
	对这三种遍历方式的总结就是：
	左中右是怎么排列的：
	1、什么序，中就在哪
	2、左右排序固定

 广度优先遍历
	层次遍历（迭代法）

要根据什么选择遍历方式？
其实没有明显的提示可以选择什么遍历方式。或者说什么遍历方式都可以实现，只是某一种方便一些
本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算。——337.打家劫舍 III


## 关于树的一些总结
> 1、做了一些题目。尤其是对于递归而言，每一次递归的开始，都把他理解为一个小子树的处理，会更好。
  2、像这种返回bool的递归，一定要确定什么时候返回true，什么时候返回false。
	 然后在return的地方调用递归。
	参考101. 对称二叉树、112. 路径总和
	基本上都是这种做法
  3、分析的代码的时候，方便理解或者是写，就从叶子结点往上走，好理解
	TreeNode* left = lowestCommonAncestor(root->left, p, q);
	TreeNode* right = lowestCommonAncestor(root->right, p, q);
	这两行代码，如果要一层一层递归进去，理解很不好理解。
	可以简化理解，这个思路在任何递归的时候，都比较好用。
	lowestCommonAncestor(root->left, p, q);  就是当前root的左子树的结果
	lowestCommonAncestor(root->right, p, q); 就是当前root的右子树的结果
	不管它内部是怎么递归的，就知道这个结果就行。
	参考：236. 二叉树的最近公共祖先

## 树的高度和深度 
>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。
 
 根据以下两点，做题的时候，选择不同的思路
 深度可以从上到下去查 所以需要前序遍历（中左右），
 高度只能从下到上去查，所以只能后序遍历（左右中）

 比如验证平衡二叉树
 是不是二叉树要看它的左右孩子的高度是不是差1，那么就选择后序遍历

## 关于树中回溯的总结
 > 回溯基于的数据结构最好是vec或者是arry这种，加的时候也是一次，删除的也是一次。不会受到数据自身长度的影响。
   比如：
   257. 二叉树的所有路径
	   vector<int> path;//path一定要vec，如果要用string的话，如果添加了一个3位数字，在回溯的时候，要回溯3次，关键你还得记录他的位数。用vec的话，pop一次就行了

## 在树中递归结束条件的写法
 > 1、如果他的任意一个子树为空，就不满足要求，就退出。
	比如验证是否为平衡二叉树的时候，
	“一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 ”
	其中任意一个孩子为空的话，就会构成他的其中一个子树的高度确定了，这个时候就要返回，算另一个子树
	110. 平衡二叉树
	```C++ []
			if (node == NULL) return 0;
	 ```
  2、如果它的左右子树都为空的时候，就退出。
  一般而言，就是用来啊、判断是否遍历到了子节点。
  257. 二叉树的所有路径
  	```C++ []
	if (cur->left == NULL && cur->right == NULL) return 0;

  3、结束条件的判断的写法，要和你递归函数的入参要对应。要不然出现空指针访问的问题。
	  3.1、入参是子节点指针，结束条件的判断，一定要是对root的判断。 searchBST(root->left, val); 《-----》  if (root == NULL || root->val == val) return root; 
		如果对root->left，就会出现nullptr->left，自然就会报错。
	  3.2、入参是root节点非子节点，结束条件的判断，才可以是对root->left等判断。
	  3.3、具体什么时候采取什么样的判断，要根据入参来。而什么样的入参，要根据题目的思路来。多体会吧。
	  3.4、  700. 二叉搜索树中的搜索 可以参考这个题目


## 在树中返回值的选择
> 1、当你发现返回值不是很好写的时候，考虑一下不要返回值，数据的修改放到参数加引用的时候。这句话很白话，但有时候确实是这样。——257. 二叉树的所有路径
  2、一般情况下：如果需要搜索整棵二叉树，那么递归函数就不要返回值。如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。——具体看112，113这两个题目

## 树的题目中有些是判断，最后返回一个bool量
> 这种题目有个固定的写法，
  在递归函数中，先判断各种true、false的情况，然后都返回。
  然后再开始递归。
  参考：101. 对称二叉树 100. 相同的树

## 突然有个想法，树的题目基本上都是递归。
> 既然都是递归，我发现很多题目树的构造，都是到了叶子节点后，然后返回上去，让root-》left 和root-》right去接，
  既然是这样，在做题目的时候，思考的思路从底部往上走，可能更简单一些

## 二叉搜索树
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
它的左、右子树也分别为二叉搜索树
1、“中序遍历”正确的搜索树，它的顺序是从小到大的。

# 前缀和
参考文章：
	https://blog.csdn.net/qq_45914558/article/details/107385862
参考题目：
	437. 路径总和 III
	560. 和为 K 的子数组
	这两个题目非常相似，最大的区别就是一个是数组，一个是树
对于数组来说，前缀和就是从数组到当前元素的和。
	用前缀和有一个很大的优势，就是可以快速的得到某一个区间的区间总和
对于树来说，一个节点的前缀和就是该节点到根之间的路径和。
总的来说，前缀和用再求区间元素的和。560就是求子区间中的元素和
437就是求子区间中的元素和。



# 回溯
## 总结一些
> 结果集合中有重复元素的话，基本上都要是对源数组要排序。排序的最后带来的效果各不相同。
  参考题目：39.组合数组 40.组合总和2

## 什么时候用回溯
> 多层for循环中，这个for的个数不能定下来，而是得变化，这个时候，就用回溯。
	因为它可以模拟for的遍历，弥补了for这个函数多层变化的情况。


## 确定返回值和参数——这其中一些想法

## 确定回溯函数结束条件——这其中一些想法
>子集问题和组合问题、分割问题的的区别，
子集是收集树形结构中树的所有节点的结果。
先ret.push_back() 再判断条件是否递归
参考：78. 子集
而组合问题、分割问题是收集树形结构中叶子节点的结果。
先判断条件是否递归 再ret.push_back() 
参考：39. 组合总和 131.分割回文串


## 确定单层搜索的过程——这其中一些想法
### 递归下次开始的位置
> 总之就是这次结束的位置+1 具体多种多样，不是简单的startIndex + 1 
  有可能也是+2 但总之都是结束的位置+1
  我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如：回溯算法：求组合问题！ (opens new window)，回溯算法：求组合总和！ (opens new window)。
  如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：回溯算法：电话号码的字母组合(opens new window)
  注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路。

### 有些时候，递归之前会进行判断。
> 重要的是else的情况，有的是continue，有的是break。选的依据是：
如果是不满足条件就不能纵向遍历了，就continue
如果是不满足条件就不能横向遍历了，就braak

### 去重要不要回溯？
>	如果要保证同一个父节点下的树层的去重，树枝是可以重复的。就不用回溯，并且就=要在for中去定义变量！
	否则就得回溯。
	参考：491.递增子序列
	要注意的是：在40.组合总和II、90.子集II (opens new window)和47.全排列 II 也是保证树层不重复，树枝可重复
	但是有区别的是，491.递增子序列是不在乎相同的两个元素的位置，而其他的则是都依赖于两个相同的元素是挨边的，所以这些题目中都有排序。
	之所以是必须挨边的是因为nums[i-1]正好就能代表上个元素。nums[i-1]==nums[i]代表了有相同的元素，要是不排序，要知道两个元素是相等的就麻烦了。得是for遍历把
	去重问题，可以根据是否能让排序，来区分使用什么方法。

### 去重
> 90. 子集 II题目和40题组合问题II 是非常相似的。是40题和78题的组合
	！这个问题和40题组合问题II的关键都是去重，这种问题的去重分为
	树枝去重，树层去重。树枝不用去重，树层才需要去重。
	nums[i-1] == nums[i] 这个时候树枝去重，树层去重都会生效，很明显不符合要求。
	加上 used[i-1]==false;才能完成树枝不用去重，树层才需要去重。
	(拓展，！加上 used[i-1]==true;才能完成树层不用去重，树枝才需要去重。比如90. 子集 II题目， used[i-1]==true;也行，就是比false性能差点)
	树枝：used[i-1]=true，used[i]=true;
	树层：used[i-1]=false，used[i]=true;

### 递归函数什么时候需要返回值，什么时候不需要
> 核心就是看最后要的结果是1个，还是多个。
  一个，就需要返回值。只有有了返回值，才能对返回值做判断，返回值复合条件了就可以返回，正好返回值的判断就在递归函数下面，接着返回，就能造成上面说的一直放回到头的效果。
  参考：37. 解数独 112. 路径总和
  多个，就不要返回值。
  参考：回溯篇章的所有题目。

# 贪心
## 总结
> 贪心思路没有公用的思路，具体问题具体分析。总之就是试试贪心可以不，可以就可以，不可以就算了。
  有些题目用贪心解出来了，但是去证明的时候，没有办法证明，证明其他非常复杂，这个没有办法。解出来就行。
  不过还有有一些思路要记录一下，这些思路可能也不仅仅适用于贪心算法：
  1、如果题目是两个维度题目，那么一定要从单个维度一一分析，每个维度都分析完了之后，再把不同的维度根据实际情况结合起来；可以是放弃一个维度的解法（406. 根据身高重建队列），可以是把两个维度用max函数结合（135. 分发糖果）。







# 动态规划
## 思路步骤
1、确定dp数组以及下标的含义
2、确定递推公式
	有的是根据“题目”来，比如dp[0]的时候，有没有实际的方法来确定值
	有的是根据“递推公式”来，比如“dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);”，为了防止下表小于0，就得初始化1，2；——198.打家劫舍
3、dp数组如何初始化
4、确定遍历顺序
5、打印dp数组

## 不同的思路下的公式
目前来看。01和完全背包，一维和二维都适用
0、纯01背包问题——装满这么大容量，最大价值是多少。
	dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

1、给定背包容量，有多少中“物品”可以装满。
	1.1、装满这个背包，“最多”要多少个“物品”
		dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); —— 474. 一和零
		dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);——1049.最后一块石头的重量II
	1.2、放满背包，“最少”有多少“物品”
		dp[i] = min(dp[i - j * j] + 1, dp[i]);——279. 完全平方数
	1.3、总结
		随着题目的不同，下表有可能是外部下标，有可能是内部下标。但下表代表的含义不变。
		dp[j]：“j”背包容量；
		dp[j - coins[i]] + 1：dp[背包容量-当前物品重量]+1：拿掉当前物品“j - coins[i]”，然后加上新的物品就是物品数+1；
		从目前来看都用min或max函数

2、给定背包容量，“能不能装满”这个背包
	dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);—— 416. 分割等和子集
	if (dp[target] == target) return true;
        return false;

	string tmp = s.substr(j, i - j);//substr(起始位置，截取的个数)——139.单词拆分，这个用“背包解决，感觉不是很好”
	if (dp[j] && wordSet.find(tmp) != wordSet.end())//if(j-i的区间能匹配，并且下标为j的时候也为true)
		dp[i] = true;//新的字符串匹配上了，说明dp为true的下表要往后挪到i了
	return dp[s.size()];

3、给定背包容量，问我们有多少种“方式”能装满
	dp[j] += dp[j - nums[i]];——494.目标和




### 01背包公式理解——整理到“不同的思路下的公式”
1、if (obstacleGrid[i][l] == 1)
		continue;
	dp[i][l] = dp[i - 1][l] + dp[i][l - 1];——63. 不同路径 II
2、dp[i][l] = dp[i - 1][l] + dp[i][l - 1];——62. 不同路径
3、	int sum = fb[0] + fb[1];
				fb[0] = fb[1];
				fb[1] = sum;——509. 斐波那契数
4、int sum = fb[2] + fb[3];
				fb[2] = fb[3];
				fb[3] = sum;——70. 爬楼梯
5、dp[2] = min(dp[1] + cost[i - 1], dp[0] + cost[i - 2]);
				dp[0] = dp[1];
				dp[1] = dp[2];——746. 使用最小花费爬楼梯


### 01背包公式理解
  做了这么几个小题，以及看了代码随想的视频，我发现他解决01背包的问题，
  往往都是先确定，这个问题能不能转成01背包的问题，然后确定物品和容量是谁，
  然后把代表物品和容量的变量，代入到01的公式中，一般来说，都是一维的dp公式，
  并且都要根据题目，来做出具体的改变，从我目前的掌握来看碰到新题目，应该是往几种上靠，想出来新的几乎不可能。

#### 二维dp数组的情况
这里说的是01背包，用二维dp数组的情况
for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i])
				dp[i][j] = dp[i - 1][j];
            else 
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
1、两层for能颠倒不？
	可以颠倒，遍历背包，再遍历物品，也是可以的。
2、for循环的解释
	外层for遍历物品，内层遍历背包容量
	！！不能倒序遍历
3、if能去掉吗？
	具体情况具体分析，在本题应该不能
4、内层for能用倒叙吗?
	不能
5、执行语句
1、dp[i][l] = max(dp[i][l], dp[i - zeroNums][l - oneNums] + 1);——474. 一和零
2、	if (j < weight[i])
		dp[i][j] = dp[i - 1][j];
	else
		dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);——纯01背包问题——dp是二维数组




#### 一维dp数组的情况
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}

1、两层for能颠倒不？
	不可以颠倒
2、for循环的解释
	外层for遍历物品，内层遍历背包容量，并且是倒叙。
	第二个for循环：
	1、int j = bagWeight;，j是背包的最大容量
	2、j >= weight[i]，“背包的容量”能不能》=“当前物品的重量”weight[i]；能大于说明能放下去。
	3、倒序遍历。比较是》=
3、max这个不一定，要看具体的题目
4、执行语句
	1、dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
	2、dp[j] = dp[j] + dp[j - coins[i]];——518. 零钱兑换 II
	3、dp[j] = dp[j] + dp[j - nums[i]];——494. 目标和
	4、dp[l] = max(dp[l], dp[l - stones[i]] + stones[i]);——1049. 最后一块石头的重量 II
	5、dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);——416. 分割等和子集
	6、dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);——纯01背包中，dp用1维数组做。
	7、dp[i] += dp[j] * dp[i - j - 1];——96. 不同的二叉搜索树
	8、dp[i] = max(dp[i], max(j*(i - j), j*dp[i - j]));——343. 整数拆分


## 完全背包问题
两层for不能随意颠倒；颠倒之后，dp数组下标对应的含义还是不变，要注意。
假设物品是12这样的顺序 
	求组合：
	用先遍历物品，再遍历背包。
	因为是遍历物品在外for循环，所以只能出现12，不会出现21

	求排列：
	用先遍历背包，再遍历物品。
	因为是遍历物品在内for循环，所以能出现12，也能出现21
两个内循环都是正序。







## 多重背包问题
> 多重背包问题，没有在力扣上出现，所以重点是前面俩个。



## 背包问题总结
### 什么时候用背包的思路
1、背包都是和动态规划的思路在一块出现。
当出现了，给你多个元素，你从这个几个元素里面“挑”几个元素来达成想要的结果。
这几个元素有着多种多样的组合方式。
2、函数是两个参数，一个参数为基本变量string，int等，一个为vec数组。
3、递归的问题，一般都可以用动态规划解决。
4、当前状态和前面状态会有一种依赖关系，那么这种依赖关系都是动规的递推公式。

### 从dp数组的定义中，确定物品和背包容量
每个题目中，不会很明显的说出谁是物品，谁是背包。
以“518. 零钱兑换 II”为例——dp【j】 金币总额为j的时候，有多少种组合。
j：本质就是：dp【i】的是随着谁变得，谁就是物品。dp【j】 是组合数量，随着金币数量变化的，所以金币数量就是j。
背包：本质就是：物品i可以放的数量。

### 内层for循环倒序，正序
二维dp数组，在01背包中，正序
一维dp数组，在01背包中，倒序
一维dp数组，在完全背包中，正序。

### 什么时候用

### 其他
我感觉背包问题，连卡子哥都讲不明白，说明我要想弄明白得花非常多的精力。
另外动态规划，背包问题的代码都是比较简单。方便记忆，我前期就别浪费太多时间去弄明白。
还是学到能在心里给自己一个“答案”就行。
二刷的时候，再回过头来就好点。


### 动态规划——股票问题总结
1、dp数组的含义都是一样的——代表手里剩余的利润，只是具体情况不同罢了。
动态规划股票问题的优势是可以用这个方法解决一系列的股票问题。
其他思路，只能解决几个。

### 子序列问题是动态规划解决的经典问题

### 子序列总结：
结果什么时候用max函数来确定？
只有dp的定义，是从下表0开始来计算最终的长度，比如“1143.最长公共子序列”，最后的返回值就是
		
### 回文子序列总结：
1、基本上都是二维数组，并且dp的定义都是i到l区间来决定怎么怎么样。

# 单调栈
什么时候用单调栈呢？
	通常是一维数组，
	要寻找任一个元素的右边或者左边“第一个”比自己大或者小的元素的"距离"，
	此时我们就要想到可以用单调栈了。时间复杂度为O(n)。
单调栈里元素是递增呢？ 还是递减呢？
	如果求一个元素右边第一个更大元素，单调栈就是递增的，
	如果求一个元素右边第一个更小元素，单调栈就是递减的。

没有求左边的？
	“接雨水”这个题目 求了左边第一个第一个比他大的和右边第一个比比它大的。

	“84.柱状图中最大的矩形”，这个题目同时检测了
	元素左边第一个更小元素和元素右边第一个更小元素

	综上两种情况来看，
	接雨水——中间的这个元素是栈顶元素，左边的是下一个栈顶元素，右边的是当前遍历到的元素。
	最大矩形——中间的这个元素是栈顶元素，左边的是下一个栈顶元素，右边的是当前遍历到的元素。

# 图论
	图论的题目，基本上都是矩阵。

# 深度优先搜索理论基础
dfs的代码框架和回溯算法的代码框架是差不多的。几乎是一样的。
void dfs(参数) {
	if (终止条件) {
		存放结果;
		return;
	}

	for (选择：本节点所连接的其他节点) {
		处理节点;
		dfs(图，选择的节点); // 递归
		回溯，撤销处理结果
	}
}
## 广度优先搜索理论基础
因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。

当然，也有一些问题是广搜 和 深搜都可以解决的，
例如岛屿问题，这类问题的特征就是不涉及具体的遍历方式，只要能把相邻且相同属性的节点标记上就行。

用队列，还是用栈，甚至用数组，都是可以的。

## 其他
第一个题目，只适合用来找路径，其他的题目套不上去。
矩阵题目的话，广度和深度都差不多。

841.钥匙和房间
参考：
https://www.programmercarl.com/0841.%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4.html#%E6%80%9D%E8%B7%AF
!这个题目提示我们要注意就是：
你的递归函数，是处理当前的节点；还是处理当前点之后的点。
关于这个，我之前的题目中有注意到过。
总的来说：
1、在递归函数有专门结束递归的语句，就是处理的是当前的点
	if (visited[key])
	return;
2、而这种，则是在遍历中去赋值；则是处理下个节点。
for (int key : keys) {
	if (visited[key] == false) {
		visited[key] = true;
		dfs(rooms, key, visited);
	}
}
！要注意的就是在调用的时候，如果是下面这种方式就要提前对结果++；
	或者做类似的处理。

# 并查集

## 并查集可以解决什么问题呢？
并查集常用来解决连通性问题。

大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。

并查集主要有两个功能：

将两个元素添加到一个集合中。
判断两个元素在不在同一个集合


并查集主要有三个功能。

1、寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个
2、将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上
3、判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点